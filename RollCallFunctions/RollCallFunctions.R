#' Functions to manipulate roll call data
#'
#' Author: Stephen R. Haptonstahl (srh@haptonstahl.org)
#' Source: https://github.com/shaptonstahl/R
#'
#' Call with:
#'   source("http://www.haptonstahl.org/R/RollCallFunctions/RollCallFunctions.R")

#' AgreementScores: Given m x n matrix of m legislators and n roll call votes, 
#'   returns m x m symetric matrix with fraction of votes on which 
#'   ij^th legislators agree.
#' ChangeIdentification: Given a vector of ideal points identified with 
#'   old.peg.values, convert to a vector of ideal points identified with new.peg.values.
#' CorrelateIdeals(id1, coord1, id2, coord2): Given two vectors of 
#'   legislator ids and two vectors of ideal points finds matched 
#'   pairs of ids and provides correlation on those ideal points.
#' CovotingMatrix: Given chamber and congress download the ORD object from Voteview
#'   and generate the corresponding covoting matrix.
#' DifferentLegislator(rc, legislators, n.legislators=2, min.votes=0): 
#'   Given a set of rollcall votes and a list of legislators (at least 
#'   length 1) return the legislator with the voting least agreement 
#'   with those already listed. Uses the taxicab norm (sum across 
#'   given legislators of the agreement scores)
#' DimensionsInVotes: Given a rollcall object uses Horn's (1965) method of
#'   Parallel Analysis to compute the number of dimensions
#' DoubleCenterSqrdDist: Given m x n matrix of m legislators and n roll call 
#'   votes, returns m x m symetric matrix with double-centered distances.
#' DropIdealLegislator: Given the results of a call to 'pscl::ideal' and a 
#'   list of legislator ids return the results having dropped the listed
#'   legislators. Used to remove legislators inserted to force identification.
#' FilterRollcallVotes(object, keep.votes, drop.votes=NULL): Given a 
#'   'rollcall' object (package: pscl) either keep or drop some votes
#' IdentifyXNormalized: Given a vector or matrix of 1-d ideal points and some 
#'   positive.peg.value, convert to a vector or matrix of ideal points 
#'   identified by positive.peg.value being positive, having mean of zero, and 
#'   having a standard deviation of 1.
#' InitializeIdeals: Given an object of class rollcall(pscl) return good 
#'   initial estimates for the ideal points and bill parameters
#' PegMinMax: Rescale so min and max are set values
#' RollCallEigen: Given a rollcall  object return the relevant eigenvalues.

source("http://www.haptonstahl.org/R/UsePackage/UsePackage.R")    #' like 'library' except that it first installs the package if necessary
UsePackage("pscl")
UsePackage("RCurl")
UsePackage('pbapply')
UsePackage('paran')

AgreementScores <- function(votes) {
  #' Given m x n matrix of m legislators and n roll call votes,
  #' returns m x m symetric matrix with fraction of votes on which 
  #' ij^th legislators agree.
  #'
  #' Author: Stephen R. Haptonstahl (srh@haptonstahl.org)
  #' source("http://www.haptonstahl.org/R/RollCallFunctions/RollCallFunctions.R")
  
  #' recode, identifying vote codes by group
  votes[votes==2] <- 1
  votes[votes==3] <- 1
  votes[votes==5] <- 4
  votes[votes==6] <- 4
  votes[votes==8] <- 7
  votes[votes==9] <- 7
  
  #' initialize output
  out <- diag(1, nrow(votes))
  
  #' generate bottom half, copy to top half
  for(i in 2:nrow(votes)) {
    for(j in 1:(i-1)) {
      out[i,j] <- mean(votes[i,]==votes[j,])
      out[j,i] <- out[i,j]
    }
  }
  return(out)
}

ChangeIdentification <- function(x, old.peg.values, new.peg.values) {
  #' Given a vector or matrix of 1-d ideal points identified with old.peg.values, 
  #' convert to a vector or matrix of ideal points identified with new.peg.values.
  #'
  #'  ex: rescaled.ideals <- ChangeIdentification(ideals, c(-1,1), c(-2,2))
  #'
  #' Author: Stephen R. Haptonstahl (srh@haptonstahl.org)
  #' source("http://www.haptonstahl.org/R/RollCallFunctions/RollCallFunctions.R")
  return( (x - old.peg.values[1]) / (old.peg.values[2] - old.peg.values[1]) * 
            (new.peg.values[2] - new.peg.values[1]) + new.peg.values[1] )
}

CorrelateIdeals <- function(id1, coord1, id2, coord2) {
  # Given two vectors of legislator ids and two vectors of ideal points
  # finds matched pairs of ids and provides correlation on those
  # ideal points.
  keepers <- intersect(id1, id2)
  keep1 <- match(keepers, id1)
  keep2 <- match(keepers, id2)
  
  return( cor(coord1[keep1], coord2[keep2]) )
}

CovotingMatrix <- function(congress,
                           chamber=c("house", "senate"),
                           base.url="ftp://voteview.com/dtaord/") {
  #' Given chamber and congress download the ORD object from Voteview
  #' and generate the corresponding covoting matrix.
  #' 
  #' The covoting matrix generated is the same format as those generated by Fowler.
  #' 
  chamber <- tolower(chamber)
  chamber <- match.arg(chamber)
  
  if("house" == chamber) {
    ord.url <- paste(base.url, "hou", congress, "kh.ord", sep="")
  } else {
    ord.url <- paste(base.url, "sen", congress, "kh.ord", sep="")
  }
  
  # download and parse the ORD file
  ord.temp <- getURI(ord.url)
  ord.temp.file <- tempfile()
  cat(ord.temp, file=ord.temp.file)
  n.votes <- nchar(readLines(ord.temp.file, n=1)) - 37
  ord <- read.fwf(ord.temp.file, widths=c(3, 5, 2, 2, 8, 3, 1, 1, 11, rep(1, n.votes)), 
                  col.names=c("congress", "ICPSR", "state.code", "district", "state.name", 
                              "party.code", "ICPSR.occupancy", "ICPSR.means", "name",
                              paste("vote", 1:n.votes, sep="")),
                  stringsAsFactors=FALSE)
  res <- file.remove(ord.temp.file)
  
  # extract the votes
  votes <- as.matrix(ord[,10:(9+n.votes)])
  
  # recode votes
  votes[ votes %in% 4:6 ] <- -1
  votes[ votes %in% 1:3 ] <- 1
  votes[ votes %in% c(0, 7:9) ] <- 0
  
  # generate covoting matrix
  rawsum.mx <- votes %*% t(votes)
  bothvoting.mx <- abs(votes) %*% t(abs(votes))
  agree.count.mx = (rawsum.mx + bothvoting.mx) / 2
  agree.rate.mx = agree.count.mx / bothvoting.mx
  
  colnames(agree.rate.mx) <- rownames(agree.rate.mx) <- ord$ICPSR
  names(dimnames(agree.rate.mx)) <- rep("ICPSR.legislator.code", 2)
  
  return(agree.rate.mx)
}
# covoting.sen112 <- CovotingMatrix(112, "senate")

DifferentLegislator <- function(rc, legislators, n.legislators=2, min.votes=0) {
  # Given a set of rollcall votes and a list of legislators (at least
  # length 1) return the legislator with the voting least agreement
  # with those already listed. Uses the taxicab norm (sum across 
  # given legislators of the agreement scores).
  
  if(class(rc) != "rollcall") stop("'rc' must be of class 'rollcall'")
  
  votes <- rc$votes
  a.scores <- AgreementScores(votes)
  if(min.votes > 0) {
    num.votes.each.legislator <- rowSums(matrix(votes %in% c(rc$codes$yea, rc$codes$nay), nrow=rc$n))
    legislators.to.exclude <- (num.votes.each.legislator < min.votes)
    a.scores[legislators.to.exclude,] <- NA
    a.scores[,legislators.to.exclude] <- NA
  }
  
  if( missing(legislators) ) {
    # Find two legislators with the largest difference from the others
    # max.distance.index <- which.max(abs(distances))
    # legislators <- c(max.distance.index %% nrow(distances), max.distance.index %/% nrow(distances)+1)
    min.agreement.index <- which.min(abs(a.scores))
    legislators <- c(min.agreement.index %% nrow(a.scores), min.agreement.index %/% nrow(a.scores)+1)
    
    while( length(legislators) < n.legislators) {
      total.agreement <- rowSums(a.scores[, legislators, drop=FALSE])
      total.agreement[legislators] <- NA
      legislators <- c(legislators, which.min(total.agreement))
    }
    
    return(legislators)
  } else {
    total.agreement <- rowSums(a.scores[, legislators])
    total.agreement[legislators] <- NA
    return( c(legislators, which.min(total.agreement)) )
  }
}
# library(pscl); rc <- readKH("ftp://voteview.com/dtaord/SEN90KH.ORD")
# DifferentLegislator(rc, n=3)
# DifferentLegislator(rc, n=10)

DimensionsInVotes <- function(rc, min.votes=5, lop=.005, n.sims=30, show.progress=TRUE) {
  #' Given a rollcall object uses Horn's (1965) method of Parallel Analysis
  #' to computer the number of dimensions
  purged.rc <- dropRollCall(rc, dropList=list(lop=ceiling(rc$n * lop)))
  if( is.null(purged.rc$m) || purged.rc$m < min.votes ) return(NA)
  
#  if(show.progress) { 
#    f <- pbreplicate 
#  } else {
#    f <- replicate
#  }
#  simulated.eigenvalues <- f(n.sims, {
#    sim.votes <- matrix(sample(0:1, purged.rc$m*purged.rc$n, replace=TRUE), ncol=purged.rc$m)
#    eigen(DoubleCenterSqrdDist(sim.votes))$values
#  })
#  mean.eigenvalues <- rowMeans(simulated.eigenvalues)
#  observed.eigenvalues <- RollCallEigen(rc, lop=lop)
#  adjusted.eigenvalues <- observed.eigenvalues - (mean.eigenvalues - 1)
#  return( list(n.dim=min(which(adjusted.eigenvalues < 1)) - 1, 
#               adj.ev=adjusted.eigenvalues,
#               obs.ev=observed.eigenvalues) )
  res <- paran(purged.rc$votes, iterations=n.sims, status=show.progress)
  return( list(n.dim=res$Retained,
               adj.ev=res$AdjEv,
               obs.ev=res$Ev) )
}

DoubleCenterSqrdDist <- function(votes) {
  #' Given m x n matrix of m legislators and n roll call votes,
  #' returns m x m symetric matrix with double-centered distances
  #'
  #' Author: Stephen R. Haptonstahl (srh@haptonstahl.org)
  #' source("http://www.haptonstahl.org/R/RollCallFunctions/RollCallFunctions.R")
  work <- AgreementScores(votes)
  work <- (1 - work)^2
  out <- sweep(work, 1, rowMeans(work))
  out <- sweep(out, 2, colMeans(work))
  out <- sweep(out, c(1,2), -mean(work))
  return(out / -2)
}

DropIdealLegislator <- function(ideal.output, legs.to.drop) {
  #' Given the results of a call to 'pscl::ideal' and a 
  #' list of legislator ids return the results having dropped the listed
  #' legislators. Used to remove legislators inserted to force identification.
  
  # Clean up list of legislators to drop
  legs.to.drop <- legs.to.drop[legs.to.drop > 0 & legs.to.drop <= ideal.output$n]
  legs.to.drop <- sort(unique(legs.to.drop))
  n.legs.to.drop <- length(legs.to.drop)
  
  legs.to.keep <- rep(TRUE, ncol(ideal.output$x))
  legs.to.keep[legs.to.drop] <- FALSE
  
  out <- ideal.output
  out$n <- out$n - n.legs.to.drop
  out$x <- out$x[,legs.to.keep,]
  out$xbar <- out$xbar[legs.to.keep,]
  
  return( out )
}

FilterRollcallVotes <- function(object, keep.votes, drop.votes=NULL) {
  # Given a 'rollcall' object (package: pscl) either keep or drop some votes.
  if( class(object) != "rollcall" ) stop("'object' must be of class 'rollcall (pscl)'")
  if( missing(keep.votes) ) {
    # drop votes
    if( !is.null(drop.votes) ) {
      keep.votes <- -1 * drop.votes
    } else {
      # do nothing
      keep.votes <- T
    }
  }
  object$votes <- as.matrix(object$votes[,keep.votes])
  if( !is.null(object$vote.data) ) object$vote.data <- object$vote.data[keep.votes,]
  object$m <- ncol(object$votes)
  return(object)
}

IdentifyXNormalized <- function(x, positive.peg.value=max(x)) {
  #' Given a vector or matrix of 1-d ideal points and some positive.peg.value, 
  #' convert to a vector or matrix of ideal points identified by 
  #' positive.peg.value being positive, having mean of zero, and having a
  #' standard deviation of 1.
  #'
  #'  ex: rescaled.ideals <- IdentifyXNormalized(ideals)
  #'  ex: rescaled.ideals <- IdentifyXNormalized(ideals, ideals[27])  # pass the vlaue, not the id
  #'
  #' Author: Stephen R. Haptonstahl (srh@haptonstahl.org)
  #' source("http://www.haptonstahl.org/R/RollCallFunctions/RollCallFunctions.R")
  old.peg.values <- c(min(x), positive.peg.value)
  new.peg.values <- (old.peg.values - mean(x)) / sd(x)
  return( ChangeIdentification(x, old.peg.values, new.peg.values) )
}

InitializeIdeals <- function(rc, anchors, anchor.values=cbind(c(-1, rep(0, d-1)), diag(d)), d=1, lop=.005) {
  #' Given an object of class rollcall(pscl) return good initial 
  #' estimates for the ideal points and bill parameters
  #' 
  #' 'anchors' is a length = d+1 integer vector of indices of the 
  #' legislators whose ideal points will be fixed for identification.
  #' 
  #' anchor.values is a d x (d+1) matrix of whose columns are the 
  #' images of the ideal points specified by 'anchors'.
  #'
  #' Author: Stephen R. Haptonstahl (srh@haptonstahl.org)
  #' source("http://www.haptonstahl.org/R/RollCallFunctions/RollCallFunctions.R")
  
  if( class(rc) != "rollcall" ) stop("Object 'rc' must be of class rollcall(pscl).")
  if( !missing(anchors) && length(anchors) != d+1 ) stop("Exactly d+1 legislators' ideal points must be specified for identification.")
  
  purged.rc <- dropRollCall(rc, dropList=list(lop=ceiling(rc$n * lop)))
  ds.agreement <- DoubleCenterSqrdDist(purged.rc$votes)
  
  eg <- eigen(ds.agreement)
  
  x <- sapply(1:d, function(this.d) eg$vectors[,this.d] / sqrt(eg$values[this.d]))
  if( missing(anchors) ) {
    anchors <- min(which(x[,1] == min(x[,1])))
    for(this.d in 1:d) {
      next.value <- (x[-anchors,this.d])[min(which(x[-anchors,this.d] == max(x[-anchors,this.d])))]
      anchors[this.d+1] <- min(which(x[,this.d] == next.value))
    }
  }
  c.1 <- anchor.values[,1]
  x.1 <- x[anchors[1],]
  c.a <- t(matrix(anchor.values[,2:(d+1)], ncol=d)) - matrix(rep(anchor.values[,1], d), ncol=d)
  x.a <- t(matrix(x[anchors[-1],], ncol=d)) - matrix(rep(x.1, d), ncol=d)
  
  scaling.matrix <- t(solve(t(x.a), t(c.a)))
  scaled.x <- apply(x, 1, function(this.x) c.1 + scaling.matrix %*% (this.x - x.1))
  if(1 == d) { 
    scaled.x <- matrix(scaled.x, ncol=1)
  } else {
    scaled.x <- t(scaled.x)
  }
  
  #' Now we have the initial estimates of the ideal points.
  #' Initial estimates of the bill parameters come from a sequence
  #' of probits.
  y <- matrix(ifelse(purged.rc$votes %in% purged.rc$codes$yea, 1, ifelse(purged.rc$votes %in% purged.rc$codes$nay, 0, NA)), nrow=purged.rc$n)
  bill.params <- apply(y, 2, function(this.y) {
    glm.result <- glm(this.y ~ ., family=binomial(link="probit"), data=data.frame(scaled.x))
    if( glm.result$converged ) {
      return( - glm.result$coef )
    } else {
      return( rep(0, d+1) )
    }
  })
  row.names(bill.params) <- c("alpha", paste("beta", 1:d, sep=""))
  
  return( list(ideal.points=scaled.x, bill.params=bill.params) )
}
#' res <- InitializeIdeals(rc); res

PegMinMax <- function(x, new.peg.values=c(-1,1)) {
  #' Rescale so min and max are set values
  return( ChangeIdentification(x, c(min(x), max(x)), new.peg.values) )
}

RollCallEigen <- function(rc, lop=0.005) {
  #' Given a rollcall  object return the relevant eigenvalues.
  #' 
  #' Author: Stephen R. Haptonstahl (srh@haptonstahl.org)
  #' source("http://www.haptonstahl.org/R/RollCallFunctions/RollCallFunctions.R")
  purged.rc <- dropRollCall(rc, dropList=list(lop=ceiling(rc$n * lop)))
  if(is.null(purged.rc$m)) return(rep(NA, rc$n))
  else return(eigen(DoubleCenterSqrdDist(purged.rc$votes))$values)
}
